<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Murajah Quiz</title>
    <!-- Vue 3 Production -->
    <script src="resources/js/vue.global.js"></script>
    <!-- Tailwind CSS -->
    <script src="resources/js/tailwind.3.4.7.js"></script>
    <!-- Custom Styles -->
    <style>
        :root {
            --color-primary: #2196f3;
            --color-secondary: #1976d2;
            --color-accent: #82b1ff;
        }
        
        /* Custom utility classes */
        .bg-primary { background-color: var(--color-primary); }
        .text-primary { color: var(--color-primary); }
        .border-primary { border-color: var(--color-primary); }
        
        .bg-secondary { background-color: var(--color-secondary); }
        .text-secondary { color: var(--color-secondary); }
        
        .bg-accent { background-color: var(--color-accent); }
        .text-accent { color: var(--color-accent); }

        /* Dark mode overrides */
        .dark .dark\:bg-gray-800 { background-color: #1a1a1a; }
        .dark .dark\:text-white { color: #ffffff; }
        .dark .dark\:hover\:bg-gray-700:hover { background-color: #2d2d2d; }
    </style>
</head>
<body class="bg-gray-50">
    <div id="app" class="min-h-screen">
        <!-- Loading Overlay -->
        <div v-if="isLoading" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white p-6 rounded-lg shadow-xl text-center">
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
                <p class="mt-4 text-gray-600">Loading...</p>
            </div>
        </div>

        <!-- Error Message -->
        <div v-if="error" class="fixed top-4 right-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded z-50">
            <p class="flex items-center">
                <span class="mr-2">‚ö†Ô∏è</span>
                {{ error }}
            </p>
        </div>

        <!-- Header -->
        <header class="bg-white shadow dark:bg-gray-800">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                <div class="flex justify-between items-center">
                    <h1 class="text-2xl font-bold text-gray-900 dark:text-white"><img src="resources/logo-bg.png" width="80" style="border-radius:15%;"></h1>
                    <nav class="flex space-x-4">
                        <button @click="toggleDarkMode" class="p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700">
                            <span v-if="isDarkMode" class="text-yellow-500">üåô</span>
                            <span v-else class="text-orange-500">‚òÄÔ∏è</span>
                        </button>
                    </nav>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
            <!-- Quiz Type Tabs -->
            <div class="mb-8">
                <div class="border-b border-gray-200">
                    <nav class="-mb-px flex space-x-8" aria-label="Quiz Types">
                        <button 
                            v-for="tab in tabs" 
                            :key="tab.id"
                            @click="currentTab = tab.id"
                            :class="[
                                currentTab === tab.id
                                    ? 'border-primary text-primary'
                                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300',
                                'whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm'
                            ]"
                        >
                            {{ tab.name }}
                        </button>
                    </nav>
                </div>
            </div>

            <!-- Quiz Content Area -->
            <div class="bg-white rounded-lg shadow p-6">
                <!-- Lightning Round -->
                <div v-if="currentTab === 'lightning-round'" class="space-y-6">
                    <!-- Selection Screen (before starting) -->
                    <div v-if="!lightningIsActive && !lightningRoundEnded">
                        <div class="text-center mb-8">
                            <h2 class="text-3xl font-bold text-primary mb-2">‚ö° Lightning Round</h2>
                            <p class="text-gray-600 text-lg">Answer as many questions as you can before time runs out!</p>
                        </div>

                        <!-- Time Selection -->
                        <div class="mb-8">
                            <h3 class="text-xl font-semibold mb-4">Select Duration:</h3>
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-3">
                                <button v-for="time in [60, 120, 180, 300]" :key="time"
                                    @click="lightningSelectedTime = time"
                                    :class="[
                                        'py-4 px-4 rounded-lg font-semibold text-lg transition-all border-2',
                                        lightningSelectedTime === time
                                            ? 'bg-primary text-white border-primary scale-105'
                                            : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-700 hover:border-primary'
                                    ]">
                                    {{ time === 60 ? '60s' : time === 120 ? '2 min' : time === 180 ? '3 min' : '5 min' }}
                                </button>
                            </div>
                        </div>

                        <!-- Difficulty Selection -->
                        <div class="mb-8">
                            <h3 class="text-xl font-semibold mb-4">Select Difficulty:</h3>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <button v-for="diff in ['easy', 'medium', 'hard']" :key="diff"
                                    @click="lightningSelectedDifficulty = diff"
                                    :class="[
                                        'py-4 px-4 rounded-lg font-semibold text-lg transition-all border-2',
                                        lightningSelectedDifficulty === diff
                                            ? 'bg-primary text-white border-primary scale-105'
                                            : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 border-gray-300 dark:border-gray-700 hover:border-primary'
                                    ]">
                                    <span class="mr-2">
                                        {{ diff === 'easy' ? 'üü¢' : diff === 'medium' ? 'üü°' : 'üî¥' }}
                                    </span>
                                    {{ diff.charAt(0).toUpperCase() + diff.slice(1) }}
                                    <div class="text-xs mt-1">
                                        {{ diff === 'easy' ? '‚ùå Ignored' : diff === 'medium' ? '3 Max' : '1 Stop' }}
                                    </div>
                                </button>
                            </div>
                        </div>

                        <!-- Start Button -->
                        <div class="text-center">
                            <button @click="startLightningRound"
                                :disabled="!lightningSelectedTime || !lightningSelectedDifficulty"
                                :class="[
                                    'px-8 py-4 rounded-lg font-bold text-lg transition-all',
                                    lightningSelectedTime && lightningSelectedDifficulty
                                        ? 'bg-primary text-white hover:bg-secondary cursor-pointer'
                                        : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                ]">
                                üöÄ Start Round
                            </button>
                        </div>
                    </div>

                    <!-- Active Round Display -->
                    <div v-else-if="lightningIsActive" class="space-y-6">
                        <!-- Timer and Stats Header -->
                        <div class="flex justify-between items-center bg-gradient-to-r from-primary to-secondary p-6 rounded-lg text-white">
                            <div>
                                <p class="text-sm opacity-90">Time Remaining</p>
                                <p class="text-4xl font-bold font-mono" :class="lightningTimeLeft <= 10 ? 'text-red-300 animate-pulse' : ''">
                                    {{ Math.floor(lightningTimeLeft / 60) }}:{{ String(lightningTimeLeft % 60).padStart(2, '0') }}
                                </p>
                            </div>
                            <div class="text-right">
                                <p class="text-lg">Score: <span class="font-bold text-2xl">{{ lightningScore }}/{{ lightningAttempts }}</span></p>
                                <p class="text-lg mt-2" :class="lightningMistakesLeft <= 1 ? 'text-red-300' : ''">
                                    {{ lightningSelectedDifficulty === 'easy' ? '‚ôæÔ∏è No Limit' : `‚ùå ${lightningMistakesLeft} Mistakes` }}
                                </p>
                            </div>
                        </div>

                        <!-- Question Display -->
                        <div v-if="lightningCurrentQuestion" class="space-y-4">
                            <div class="text-center mb-6">
                                <span class="inline-block bg-accent text-white px-4 py-2 rounded-full text-sm font-semibold">
                                    {{ lightningCurrentQuestionType === 'continuation' 
                                        ? (lightningCurrentQuestion.type === 'next' ? '‚¨áÔ∏è Next Verse' : '‚¨ÜÔ∏è Previous Verse')
                                        : 'üìñ Translation' 
                                    }}
                                </span>
                            </div>

                            <!-- Question Text -->
                            <div class="p-6 bg-gray-50 dark:bg-gray-800 rounded-lg">
                                <p class="text-2xl text-right font-arabic" style="line-height: 2;">{{ lightningCurrentQuestion.text }}</p>
                                <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
                                    Surah {{ lightningCurrentQuestion.chapter }}, Verse {{ lightningCurrentQuestion.verse }}
                                </p>
                            </div>

                            <!-- Answer Options -->
                            <div class="grid gap-3">
                                <button v-for="(option, index) in lightningOptions" :key="index"
                                    @click="checkLightningAnswer(index)"
                                    :disabled="lightningAnswerRevealed"
                                    :class="[
                                        'p-4 rounded-lg text-left transition-all border-2',
                                        lightningAnswerRevealed
                                            ? (option.isCorrect 
                                                ? 'bg-green-100 dark:bg-green-900 border-green-500 text-green-700 dark:text-green-200' 
                                                : 'bg-gray-100 dark:bg-gray-800 border-gray-300 text-gray-600 dark:text-gray-400')
                                            : 'bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-700 hover:border-primary hover:bg-blue-50 dark:hover:bg-blue-900/30'
                                    ]">
                                    <p class="font-medium text-right font-arabic" style="line-height: 1.6;">{{ option.text }}</p>
                                </button>
                            </div>

                            <!-- Feedback -->
                            <div v-if="lightningAnswerRevealed" class="text-center">
                                <div v-if="lightningAnswerIsCorrect" class="text-green-600 font-bold text-lg">
                                    ‚úÖ Correct!
                                </div>
                                <div v-else class="text-red-600 font-bold text-lg">
                                    ‚ùå Incorrect!
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Round End Summary -->
                    <div v-else-if="lightningRoundEnded" class="text-center space-y-6">
                        <h2 class="text-3xl font-bold">Round Complete! üéâ</h2>
                        <div class="bg-gradient-to-br from-primary/10 to-secondary/10 rounded-lg p-8 space-y-4">
                            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                                <div>
                                    <p class="text-sm text-gray-600">Final Score</p>
                                    <p class="text-3xl font-bold text-primary">{{ lightningScore }}</p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-600">Questions</p>
                                    <p class="text-3xl font-bold">{{ lightningAttempts }}</p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-600">Accuracy</p>
                                    <p class="text-3xl font-bold text-green-500">{{ lightningAttempts ? Math.round((lightningScore / lightningAttempts) * 100) : 0 }}%</p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-600">Difficulty</p>
                                    <p class="text-2xl font-bold">{{ lightningSelectedDifficulty.toUpperCase() }}</p>
                                </div>
                            </div>
                        </div>
                        <div class="flex gap-4 justify-center">
                            <button @click="resetLightningRound" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-secondary font-semibold">
                                Play Again
                            </button>
                            <button @click="saveLightningScore" class="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 font-semibold">
                                Save Score
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Verse Completion -->
                <div v-if="currentTab === 'verse-completion'" class="space-y-6">
                    <div class="flex justify-between items-start">
                        <div>
                            <h2 class="text-lg font-semibold">Verse Completion</h2>
                            <p class="text-gray-600">Fill in the missing words from the verse.</p>
                        </div>
                        
                        <!-- Score Display -->
                        <div class="text-right">
                            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                                <div class="mb-2">
                                    <p class="text-sm text-gray-600 dark:text-gray-400">Score</p>
                                    <p class="text-2xl font-bold text-primary">
                                        {{ completionScore }}/{{ completionAttempts }}
                                        <span class="text-sm text-gray-500">
                                            ({{ completionAttempts ? Math.round((completionScore/completionAttempts) * 100) : 0 }}%)
                                        </span>
                                    </p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">Current Streak</p>
                                    <p class="text-xl font-bold" :class="completionStreak >= 5 ? 'text-green-500' : 'text-gray-700 dark:text-gray-300'">
                                        {{ completionStreak }} üî•
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quiz Container -->
                    <div v-if="!selectedSurahs.length" class="text-center py-12">
                        <p class="text-gray-600">Please select some surahs from the configuration first</p>
                        <button @click="currentTab = 'config'" class="mt-4 text-primary hover:underline">
                            Go to Configuration
                        </button>
                    </div>

                    <div v-else-if="!completionVerse && !isLoading" class="text-center py-12">
                        <button @click="generateCompletionQuestion" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-secondary">
                            Start Quiz
                        </button>
                    </div>
                    
                    <div v-else-if="isLoading" class="text-center py-12">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
                        <p class="mt-4 text-gray-600">Loading question...</p>
                    </div>

                    <!-- Question Display -->
                    <div v-else-if="completionVerse" class="space-y-6">
                        <!-- Current Verse with Blanks -->
                        <div class="p-6 bg-gray-50 dark:bg-gray-800 rounded-lg">
                            <p class="text-sm text-gray-500 dark:text-gray-400 mb-2">
                                Surah {{ completionVerse.chapter }}, Verse {{ completionVerse.verse }}
                            </p>
                            <div class="text-2xl text-right font-arabic" style="line-height: 2.5;">
                                <span v-for="(word, index) in completionVerseDisplay || []" :key="index">
                                    <span v-if="word.isBlank" class="inline-block bg-yellow-200 dark:bg-yellow-900 text-yellow-900 dark:text-yellow-100 px-2 py-1 rounded mx-1 min-w-[100px] text-center font-semibold">
                                        {{ getFilledWord(word.originalIndex) || '___' }}
                                    </span>
                                    <span v-else class="mx-1">
                                        {{ word.text }}
                                    </span>
                                </span>
                            </div>
                        </div>

                        <!-- Progress -->
                        <div v-if="!completionAnswerRevealed" class="bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg p-4">
                            <p class="text-sm text-blue-900 dark:text-blue-200">
                                Missing words: {{ completionMissingCount }} / {{ completionCorrectAnswers ? completionCorrectAnswers.length : 0 }}
                            </p>
                            <div class="w-full bg-blue-200 dark:bg-blue-800 rounded-full h-2 mt-2">
                                <div class="bg-blue-600 h-2 rounded-full transition-all" :style="{ width: (completionCorrectAnswers && completionTotalMissing ? (completionMissingCount / completionTotalMissing * 100) : 0) + '%' }"></div>
                            </div>
                        </div>

                        <!-- Word Options -->
                        <div class="space-y-4">
                            <p class="text-sm font-medium text-gray-700 dark:text-gray-300">Select the correct words in order (right to left):</p>
                            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                                <button v-for="(option, index) in (completionOptions || [])" 
                                    :key="index"
                                    @click="selectCompletionWord(index)"
                                    :disabled="completionAnswerRevealed || completionSelectedWords.includes(index)"
                                    :class="[
                                        'p-3 rounded-lg font-arabic transition-colors border-2',
                                        completionSelectedWords.includes(index)
                                            ? 'bg-gray-300 dark:bg-gray-600 border-gray-400 text-gray-600 dark:text-gray-400 cursor-not-allowed'
                                            : completionAnswerRevealed
                                                ? option?.isCorrect ? 'bg-green-100 dark:bg-green-900 border-green-500 text-green-700 dark:text-green-200' : 'bg-gray-100 dark:bg-gray-800 border-gray-300'
                                                : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-primary hover:bg-blue-50 dark:hover:bg-blue-900/30'
                                    ]">
                                    <p class="text-lg" style="line-height: 1.5;">{{ option?.text || '?' }}</p>
                                </button>
                            </div>
                        </div>

                        <!-- Selected Words Display -->
                        <div v-if="completionSelectedWords.length > 0 && !completionAnswerRevealed" class="bg-purple-50 dark:bg-purple-900/30 border border-purple-200 dark:border-purple-700 rounded-lg p-4">
                            <div class="flex items-center justify-between">
                                <div>
                                    <p class="text-sm text-purple-900 dark:text-purple-200 mb-2">Words selected: {{ completionSelectedWords.length }} / {{ completionCorrectAnswers ? completionCorrectAnswers.length : 0 }}</p>
                                    <div class="flex flex-wrap gap-2">
                                        <span v-for="(wordIndex, position) in completionSelectedWords" :key="position" class="bg-purple-200 dark:bg-purple-800 text-purple-900 dark:text-purple-100 px-3 py-1 rounded-full text-sm">
                                            {{ position + 1 }}. {{ (completionOptions && completionOptions[wordIndex]) ? completionOptions[wordIndex].text : '?' }}
                                        </span>
                                    </div>
                                </div>
                                <button @click="checkCompletionAnswer" class="px-6 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 whitespace-nowrap">
                                    Check Answer
                                </button>
                            </div>
                        </div>

                        <!-- Result Display -->
                        <div v-if="completionAnswerRevealed" class="space-y-3">
                            <div v-if="completionIsCorrect" class="bg-green-50 dark:bg-green-900/30 border border-green-500 rounded-lg p-4">
                                <p class="text-green-700 dark:text-green-200 font-semibold text-lg">‚úÖ Correct! All words in the right order!</p>
                            </div>
                            <div v-else class="bg-red-50 dark:bg-red-900/30 border border-red-500 rounded-lg p-4">
                                <p class="text-red-700 dark:text-red-200 font-semibold">‚ùå Incorrect order or words</p>
                                <div class="mt-3 text-right font-arabic">
                                    <p class="text-sm text-gray-600 dark:text-gray-400 mb-1">Correct order:</p>
                                    <p class="text-xl" style="line-height: 2;">{{ completionVerse.text }}</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div v-if="error" class="text-red-500 text-center mt-4">
                        {{ error }}
                    </div>
                </div>

                <!-- Test Continuation -->
                <div v-if="currentTab === 'multiple-choice'" class="space-y-6">
                    <div class="flex justify-between items-start">
                        <div>
                            <h2 class="text-lg font-semibold">Test Continuation</h2>
                            <p class="text-gray-600">
                                Select the 
                                <span v-if="continuationType === 'next'" class="ml-2 inline-block bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-200 px-3 py-1 rounded-full font-semibold">
                                    ‚¨áÔ∏è NEXT VERSE
                                </span>
                                <span v-else class="ml-2 inline-block bg-orange-100 dark:bg-orange-900 text-orange-700 dark:text-orange-200 px-3 py-1 rounded-full font-semibold">
                                    ‚¨ÜÔ∏è PREVIOUS VERSE
                                </span>
                            </p>
                        </div>
                        
                        <!-- Score Display -->
                        <div class="text-right">
                            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                                <div class="mb-2">
                                    <p class="text-sm text-gray-600 dark:text-gray-400">Score</p>
                                    <p class="text-2xl font-bold text-primary">
                                        {{ continuationScore }}/{{ continuationAttempts }}
                                        <span class="text-sm text-gray-500">
                                            ({{ continuationAttempts ? Math.round((continuationScore/continuationAttempts) * 100) : 0 }}%)
                                        </span>
                                    </p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">Current Streak</p>
                                    <p class="text-xl font-bold" :class="continuationStreak >= 5 ? 'text-green-500' : 'text-gray-700 dark:text-gray-300'">
                                        {{ continuationStreak }} üî•
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quiz Container -->
                    <div v-if="!selectedSurahs.length" class="text-center py-12">
                        <p class="text-gray-600">Please select some surahs from the configuration first</p>
                        <button @click="currentTab = 'config'" class="mt-4 text-primary hover:underline">
                            Go to Configuration
                        </button>
                    </div>

                    <div v-else-if="!continuationVerse && !isLoading" class="text-center py-12">
                        <button @click="generateContinuationQuestion" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-secondary">
                            Start Quiz
                        </button>
                    </div>
                    
                    <div v-else-if="isLoading" class="text-center py-12">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
                        <p class="mt-4 text-gray-600">Loading question...</p>
                    </div>

                    <!-- Question Display -->
                    <div v-else-if="continuationVerse" class="space-y-6">
                        <!-- Current Verse -->
                        <div class="p-6 bg-gray-50 dark:bg-gray-800 rounded-lg">
                            <p class="text-2xl text-right font-arabic" style="line-height: 2;">{{ continuationVerse.text }}</p>
                            <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">
                                Surah {{ continuationVerse.chapter }}, Verse {{ continuationVerse.verse }}
                            </p>
                        </div>

                        <!-- Options -->
                        <div class="grid gap-4">
                            <template v-if="!continuationAnswerRevealed">
                                <button v-for="(option, index) in continuationOptions" 
                                    :key="index"
                                    @click="checkContinuationAnswer(index)"
                                    class="p-4 rounded-lg text-right font-arabic transition-colors border-2 bg-white border-gray-200 hover:border-primary dark:bg-gray-800 dark:border-gray-700 dark:hover:border-primary">
                                    <p class="text-2xl" style="line-height: 2;">{{ option.text }}</p>
                                </button>
                            </template>
                            <template v-else>
                                <!-- After answer selection -->
                                <div v-if="selectedWrongContinuation !== null" class="p-4 rounded-lg text-right font-arabic border-2 bg-red-50 border-red-500 dark:bg-red-900/30">
                                    <p class="text-2xl text-red-600 dark:text-red-400" style="line-height: 2;">
                                        {{ continuationOptions[selectedWrongContinuation].text }}
                                    </p>
                                    <p class="text-sm text-red-500 dark:text-red-400 mt-2">
                                        ‚ùå Incorrect Answer (Verse {{ continuationOptions[selectedWrongContinuation].verse }})
                                    </p>
                                </div>
                                <div class="p-6 rounded-lg text-right font-arabic border-2 bg-green-50 border-green-500 dark:bg-green-900/30">
                                    <p class="text-2xl text-green-700 dark:text-green-400" style="line-height: 2;">
                                        {{ continuationOptions.find(opt => opt.isCorrect).text }}
                                    </p>
                                    <p class="text-sm text-green-600 dark:text-green-500 mt-2">
                                        ‚úÖ Correct Answer (Verse {{ continuationOptions.find(opt => opt.isCorrect).verse }})
                                    </p>
                                </div>
                            </template>
                        </div>
                    </div>

                    <div v-if="error" class="text-red-500 text-center mt-4">
                        {{ error }}
                    </div>
                </div>

                <!-- Translation Match -->
                <div v-if="currentTab === 'translation-match'" class="space-y-6">
                    <div class="flex justify-between items-start">
                        <div>
                            <h2 class="text-lg font-semibold">Translation Match</h2>
                            <p class="text-gray-600">Match verses with their translations.</p>
                        </div>
                        
                        <!-- Score Display -->
                        <div class="text-right">
                            <div class="bg-gray-100 dark:bg-gray-800 rounded-lg p-4">
                                <div class="mb-2">
                                    <p class="text-sm text-gray-600 dark:text-gray-400">Score</p>
                                    <p class="text-2xl font-bold text-primary">
                                        {{ sessionScore }}/{{ sessionAttempts }}
                                        <span class="text-sm text-gray-500">
                                            ({{ sessionAttempts ? Math.round((sessionScore/sessionAttempts) * 100) : 0 }}%)
                                        </span>
                                    </p>
                                </div>
                                <div>
                                    <p class="text-sm text-gray-600 dark:text-gray-400">Current Streak</p>
                                    <p class="text-xl font-bold" :class="streak >= 5 ? 'text-green-500' : 'text-gray-700 dark:text-gray-300'">
                                        {{ streak }} üî•
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Quiz Container -->
                    <div v-if="!selectedSurahs.length" class="text-center py-12">
                        <p class="text-gray-600">Please select some surahs from the configuration first</p>
                        <button @click="currentTab = 'config'" class="mt-4 text-primary hover:underline">
                            Go to Configuration
                        </button>
                    </div>

                    <div v-else-if="!currentVerse && !isLoading" class="text-center py-12">
                        <button @click="generateNewQuestion" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-secondary">
                            Start Quiz
                        </button>
                    </div>
                    
                    <div v-else-if="isLoading" class="text-center py-12">
                        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-primary mx-auto"></div>
                        <p class="mt-4 text-gray-600">Loading question...</p>
                    </div>

                    <!-- Question Display -->
                    <div v-else-if="currentVerse" class="space-y-6">
                        <!-- Verse -->
                        <div class="p-6 bg-gray-50 dark:bg-gray-800 rounded-lg">
                            <p class="text-2xl text-right font-arabic" style="line-height: 2;">{{ currentVerse.text }}</p>
                            <p class="text-sm text-gray-500 dark:text-gray-400 mt-2">Surah {{ currentVerse.chapter }}, Verse {{ currentVerse.verse }}</p>
                        </div>

                        <!-- Translation Options -->
                        <div class="grid gap-4">
                            <template v-if="!answerRevealed">
                                <!-- Before answer selection -->
                                <button v-for="(option, index) in translationOptions" 
                                    :key="index"
                                    @click="checkAnswer(index)"
                                    class="p-4 rounded-lg text-left transition-colors border-2 bg-white border-gray-200 hover:border-primary dark:bg-gray-800 dark:border-gray-700 dark:hover:border-primary">
                                    <p class="text-lg">{{ option.text }}</p>
                                </button>
                            </template>
                            <template v-else>
                                <!-- After answer selection -->
                                <div v-if="selectedWrongAnswer !== null" class="p-4 rounded-lg text-left border-2 bg-red-50 border-red-500 dark:bg-red-900/30">
                                    <p class="text-lg text-red-600 dark:text-red-400">
                                        {{ translationOptions[selectedWrongAnswer].text }}
                                    </p>
                                    <p class="text-sm text-red-500 dark:text-red-400 mt-2">
                                        ‚ùå Incorrect Answer
                                    </p>
                                </div>
                                <div class="p-6 rounded-lg text-left border-2 bg-green-50 border-green-500 dark:bg-green-900/30">
                                    <p class="text-2xl font-medium text-green-700 dark:text-green-400">
                                        {{ translationOptions.find(opt => opt.isCorrect).text }}
                                    </p>
                                    <p class="text-sm text-green-600 dark:text-green-500 mt-2">
                                        ‚úÖ Correct Answer
                                    </p>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>

                <!-- Configuration -->
                <div v-if="currentTab === 'config'" class="space-y-6">
                    <div>
                        <h2 class="text-lg font-semibold mb-4">Quiz Settings</h2>
                        <div class="space-y-4">
                            <!-- Default Settings Actions -->
                            <div class="bg-blue-50 dark:bg-blue-900/30 border border-blue-200 dark:border-blue-700 rounded-lg p-4">
                                <h3 class="text-md font-medium text-blue-900 dark:text-blue-200 mb-3">Default Settings</h3>
                                <div class="flex flex-wrap gap-2">
                                    <button @click="saveDefaultSettings" 
                                        class="px-4 py-2 text-sm bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors">
                                        üíæ Save as Default
                                    </button>
                                    <button @click="loadDefaultSettings" 
                                        class="px-4 py-2 text-sm bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors">
                                        üì• Load Default Settings
                                    </button>
                                </div>
                            </div>

                            <!-- Surah Selection -->
                            <div>
                                <h3 class="text-md font-medium text-gray-700 mb-2">Select Surahs for Quiz</h3>
                                <div class="flex flex-wrap gap-2 mb-4">
                                    <button @click="toggleAllSurahs" 
                                        class="px-3 py-1 text-sm rounded-md"
                                        :class="allSurahsSelected ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'">
                                        {{ allSurahsSelected ? 'Deselect All' : 'Select All' }}
                                    </button>
                                    <button @click="saveConfig" 
                                        class="px-3 py-1 text-sm bg-primary text-white rounded-md">
                                        Save Settings
                                    </button>
                                </div>
                                <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2">
                                    <div v-for="(name, number) in surahs" 
                                        :key="number"
                                        @click="toggleSurah(number)"
                                        class="flex items-center p-2 rounded-lg cursor-pointer transition-colors"
                                        :class="selectedSurahs.includes(number) ? 'bg-primary text-white' : 'bg-gray-100 hover:bg-gray-200'">
                                        <span class="mr-2 text-sm">{{ number }}.</span>
                                        <span class="font-arabic text-lg">{{ name }}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="bg-white border-t mt-12">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
                <p class="text-center text-gray-500 text-sm">
                    Murajah Quiz ¬© 2025
                </p>
            </div>
        </footer>
    </div>

    <!-- Database Setup -->
    <script>
        // IndexedDB Setup
        const QuizDB = {
            db: null,
            DB_NAME: 'MurajahQuizDB',
            VERSION: 1,

            // Store names
            STORES: {
                PROGRESS: 'quizProgress',
                SETTINGS: 'settings',
                SCORES: 'scores',
                BOOKMARKS: 'bookmarks'
            },

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.DB_NAME, this.VERSION);

                    request.onerror = () => {
                        console.error('Failed to open database:', request.error);
                        reject(request.error);
                    };

                    request.onsuccess = () => {
                        this.db = request.result;
                        console.log('Database opened successfully');
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Quiz Progress Store
                        if (!db.objectStoreNames.contains(this.STORES.PROGRESS)) {
                            const progressStore = db.createObjectStore(this.STORES.PROGRESS, { keyPath: 'id', autoIncrement: true });
                            progressStore.createIndex('quizType', 'quizType', { unique: false });
                            progressStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }

                        // Settings Store
                        if (!db.objectStoreNames.contains(this.STORES.SETTINGS)) {
                            db.createObjectStore(this.STORES.SETTINGS, { keyPath: 'key' });
                        }

                        // Scores Store
                        if (!db.objectStoreNames.contains(this.STORES.SCORES)) {
                            const scoresStore = db.createObjectStore(this.STORES.SCORES, { keyPath: 'id', autoIncrement: true });
                            scoresStore.createIndex('quizType', 'quizType', { unique: false });
                            scoresStore.createIndex('score', 'score', { unique: false });
                            scoresStore.createIndex('timestamp', 'timestamp', { unique: false });
                        }

                        // Bookmarks Store
                        if (!db.objectStoreNames.contains(this.STORES.BOOKMARKS)) {
                            const bookmarksStore = db.createObjectStore(this.STORES.BOOKMARKS, { keyPath: 'id', autoIncrement: true });
                            bookmarksStore.createIndex('type', 'type', { unique: false });
                            bookmarksStore.createIndex('reference', 'reference', { unique: false });
                        }
                    };
                });
            },

            // Generic CRUD operations
            async add(storeName, data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.add({ ...data, timestamp: Date.now() });

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            async get(storeName, id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(id);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            async getAll(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            async update(storeName, id, data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put({ ...data, id, timestamp: Date.now() });

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            async delete(storeName, id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(storeName, 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(id);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            // Specific quiz operations
            async saveQuizProgress(quizType, data) {
                return this.add(this.STORES.PROGRESS, {
                    quizType,
                    ...data
                });
            },

            async getQuizProgress(quizType) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(this.STORES.PROGRESS, 'readonly');
                    const store = transaction.objectStore(this.STORES.PROGRESS);
                    const index = store.index('quizType');
                    const request = index.getAll(quizType);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            async saveScore(quizType, score, details = {}) {
                return this.add(this.STORES.SCORES, {
                    quizType,
                    score,
                    details
                });
            },

            async getScores(quizType) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(this.STORES.SCORES, 'readonly');
                    const store = transaction.objectStore(this.STORES.SCORES);
                    const index = store.index('quizType');
                    const request = index.getAll(quizType);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            },

            async setSetting(key, value) {
                try {
                    // First try to delete any existing setting
                    try {
                        await this.delete(this.STORES.SETTINGS, key);
                    } catch (e) {
                        // Ignore delete errors
                    }
                    
                    // Then add the new setting
                    return await this.add(this.STORES.SETTINGS, { 
                        key, 
                        value: JSON.stringify(value),
                        timestamp: Date.now()
                    });
                } catch (err) {
                    console.error('Error saving setting:', err);
                    throw err;
                }
            },

            async getSetting(key) {
                try {
                    const setting = await this.get(this.STORES.SETTINGS, key);
                    if (setting) {
                        return {
                            ...setting,
                            value: JSON.parse(setting.value)
                        };
                    }
                    return null;
                } catch (err) {
                    console.error('Error getting setting:', err);
                    return null;
                }
            }
        };
    </script>

    <!-- Vue App Script -->
    <script>
        const { createApp, ref } = Vue

        createApp({
            setup() {
                const isDarkMode = ref(false)
                const currentTab = ref('word-match')
                const isLoading = ref(true)
                const error = ref(null)
                const surahs = ref({})
                const selectedSurahs = ref([])
                const allSurahsSelected = ref(false)
                const quranData = ref({})
                const translationData = ref({})
                const currentVerse = ref(null)
                const translationOptions = ref([])
                const answerRevealed = ref(false)
                const selectedWrongAnswer = ref(null)
                const sessionScore = ref(0)
                const sessionAttempts = ref(0)
                const streak = ref(0)

                // Test Continuation Quiz State
                const continuationVerse = ref(null)
                const continuationOptions = ref([])
                const continuationAnswerRevealed = ref(false)
                const selectedWrongContinuation = ref(null)
                const continuationScore = ref(0)
                const continuationAttempts = ref(0)
                const continuationStreak = ref(0)
                const continuationType = ref('next') // 'next' or 'previous'

                // Verse Completion Quiz State
                const completionVerse = ref(null)
                const completionVerseDisplay = ref([])
                const completionOptions = ref([])
                const completionSelectedWords = ref([])
                const completionAnswerRevealed = ref(false)
                const completionIsCorrect = ref(false)
                const completionScore = ref(0)
                const completionAttempts = ref(0)
                const completionStreak = ref(0)
                const completionCorrectAnswers = ref([])
                const completionTotalMissing = ref(0)
                const completionMissingCount = ref(0)
                const completionBlankIndices = ref([]) // Indices of blank words in verse
                const completionFilledWords = ref({}) // Map of blank position -> filled word

                // Lightning Round State
                const lightningSelectedTime = ref(null) // Selected time in seconds: 60, 120, 180, 300
                const lightningSelectedDifficulty = ref(null) // 'easy', 'medium', 'hard'
                const lightningTimeLeft = ref(0) // Current countdown in seconds
                const lightningTotalTime = ref(0) // Original selected time
                const lightningScore = ref(0) // Questions answered correctly
                const lightningAttempts = ref(0) // Total questions asked
                const lightningMistakesLeft = ref(0) // Mistakes remaining
                const lightningMaxMistakes = ref(0) // Max mistakes allowed based on difficulty
                const lightningIsActive = ref(false) // Is round currently running
                const lightningCurrentQuestion = ref(null) // Current question data
                const lightningCurrentQuestionType = ref(null) // 'continuation' or 'translation'
                const lightningOptions = ref([]) // Current question options
                const lightningAnswerRevealed = ref(false) // Has answer been revealed
                const lightningAnswerIsCorrect = ref(false) // Was answer correct
                const lightningTimerId = ref(null) // Store timer ID for cleanup
                const lightningRoundEnded = ref(false) // Has round ended
                const lightningTimeRemaining = ref(0) // Time remaining when round ended (for stats)

                // Load quiz data
                const loadQuizData = async () => {
                    try {
                        const [quranResponse, translationResponse] = await Promise.all([
                            fetch('resources/quran.json'),
                            fetch('resources/en.json')
                        ]);
                        quranData.value = await quranResponse.json();
                        translationData.value = await translationResponse.json();
                    } catch (err) {
                        console.error('Failed to load quiz data:', err);
                        error.value = 'Failed to load quiz data.';
                    }
                };

                // Get random verses excluding current verse
                const getRandomVerses = (currentVerse, count) => {
                    const allVerses = [];
                    Object.keys(translationData.value).forEach(surahNum => {
                        Object.values(translationData.value[surahNum]).forEach(verse => {
                            if (verse.chapter !== currentVerse.chapter || verse.verse !== currentVerse.verse) {
                                allVerses.push(verse);
                            }
                        });
                    });
                    
                    const result = [];
                    while (result.length < count && allVerses.length > 0) {
                        const randomIndex = Math.floor(Math.random() * allVerses.length);
                        result.push(allVerses.splice(randomIndex, 1)[0]);
                    }
                    return result;
                };

                // Generate new question
                const generateNewQuestion = async () => {
                    if (!selectedSurahs.value.length) return;
                    
                    // Reset scores if this is a new session (no current verse)
                    if (!currentVerse.value) {
                        sessionScore.value = 0;
                        sessionAttempts.value = 0;
                        streak.value = 0;
                    }
                    
                    isLoading.value = true;
                    answerRevealed.value = false;
                    selectedWrongAnswer.value = null;
                    
                    try {
                        // Select random surah from selected ones
                        const randomSurahNum = selectedSurahs.value[
                            Math.floor(Math.random() * selectedSurahs.value.length)
                        ];
                        
                        // Get random verse from that surah
                        const surahVerses = quranData.value[randomSurahNum];
                        const randomVerseIndex = Math.floor(Math.random() * surahVerses.length);
                        const verseNumber = randomVerseIndex + 1;
                        
                        // Set current verse
                        currentVerse.value = {
                            chapter: parseInt(randomSurahNum),
                            verse: verseNumber,
                            text: surahVerses[randomVerseIndex].text
                        };

                        // Get correct translation
                        const correctTranslation = translationData.value[randomSurahNum].find(
                            v => v.verse === verseNumber
                        );

                        // Get 3 random wrong translations
                        const wrongTranslations = getRandomVerses(currentVerse.value, 3);

                        // Combine and shuffle options
                        const options = [
                            { text: correctTranslation.text, isCorrect: true },
                            ...wrongTranslations.map(t => ({ text: t.text, isCorrect: false }))
                        ];
                        
                        // Fisher-Yates shuffle
                        for (let i = options.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [options[i], options[j]] = [options[j], options[i]];
                        }

                        translationOptions.value = options;
                    } catch (err) {
                        console.error('Error generating question:', err);
                        error.value = 'Failed to generate question.';
                    } finally {
                        isLoading.value = false;
                    }
                };

                // Check answer
                const checkAnswer = async (index) => {
                    answerRevealed.value = true;
                    const isCorrect = translationOptions.value[index].isCorrect;
                    
                    if (!isCorrect) {
                        selectedWrongAnswer.value = index;
                    }
                    
                    // Update session score
                    sessionAttempts.value++;
                    if (isCorrect) {
                        sessionScore.value++;
                        streak.value++;
                    } else {
                        streak.value = 0;
                    }
                    
                    // Save score
                    try {
                        await QuizDB.saveScore('translation-match', isCorrect ? 1 : 0, {
                            surah: currentVerse.value.chapter,
                            verse: currentVerse.value.verse,
                            selectedAnswer: translationOptions.value[index].text,
                            streak: streak.value
                        });
                    } catch (err) {
                        console.error('Error saving score:', err);
                    }

                    // Auto-generate new question after delay
                    setTimeout(() => {
                        generateNewQuestion();
                    }, 3000);
                };

                // Load surahs data
                const loadSurahs = async () => {
                    try {
                        const response = await fetch('resources/surah-names.json')
                        const data = await response.json()
                        surahs.value = data
                        
                        // Load saved surah selection
                        const savedSelection = await QuizDB.getSetting('selectedSurahs')
                        if (savedSelection) {
                            selectedSurahs.value = savedSelection.value
                            updateAllSurahsState()
                        }
                    } catch (err) {
                        console.error('Failed to load surahs:', err)
                        error.value = 'Failed to load Surah list.'
                    }
                }

                // Toggle individual surah selection
                const toggleSurah = (number) => {
                    const index = selectedSurahs.value.indexOf(number)
                    if (index === -1) {
                        selectedSurahs.value.push(number)
                    } else {
                        selectedSurahs.value.splice(index, 1)
                    }
                    updateAllSurahsState()
                }

                // Update all surahs selected state
                const updateAllSurahsState = () => {
                    allSurahsSelected.value = selectedSurahs.value.length === Object.keys(surahs.value).length
                }

                // Toggle all surahs
                const toggleAllSurahs = () => {
                    if (allSurahsSelected.value) {
                        selectedSurahs.value = []
                    } else {
                        selectedSurahs.value = Object.keys(surahs.value)
                    }
                    updateAllSurahsState()
                }

                // Save configuration
                const saveConfig = async () => {
                    try {
                        await QuizDB.setSetting('selectedSurahs', selectedSurahs.value)
                        // Show success message
                        const prevError = error.value
                        error.value = 'Settings saved successfully!'
                        setTimeout(() => {
                            if (error.value === 'Settings saved successfully!') {
                                error.value = prevError
                            }
                        }, 2000)
                    } catch (err) {
                        console.error('Failed to save settings:', err)
                        error.value = 'Failed to save settings.'
                    }
                }

                // Save default settings
                const saveDefaultSettings = async () => {
                    try {
                        await QuizDB.setSetting('defaultSurahs', selectedSurahs.value)
                        // Show success message
                        const prevError = error.value
                        error.value = '‚úÖ Default settings saved successfully!'
                        setTimeout(() => {
                            if (error.value === '‚úÖ Default settings saved successfully!') {
                                error.value = prevError
                            }
                        }, 2000)
                    } catch (err) {
                        console.error('Failed to save default settings:', err)
                        error.value = 'Failed to save default settings.'
                    }
                }

                // Load default settings
                const loadDefaultSettings = async () => {
                    try {
                        const defaultSettings = await QuizDB.getSetting('defaultSurahs')
                        if (defaultSettings && defaultSettings.value) {
                            selectedSurahs.value = defaultSettings.value
                            updateAllSurahsState()
                            // Show success message
                            const prevError = error.value
                            error.value = '‚úÖ Default settings loaded successfully!'
                            setTimeout(() => {
                                if (error.value === '‚úÖ Default settings loaded successfully!') {
                                    error.value = prevError
                                }
                            }, 2000)
                        } else {
                            error.value = 'No default settings found. Please save settings as default first.'
                            setTimeout(() => {
                                error.value = null
                            }, 3000)
                        }
                    } catch (err) {
                        console.error('Failed to load default settings:', err)
                        error.value = 'Failed to load default settings.'
                    }
                }

                // Generate completion question
                const generateCompletionQuestion = async () => {
                    if (!selectedSurahs.value.length) return;
                    
                    // Reset scores if this is a new session
                    if (!completionVerse.value) {
                        completionScore.value = 0;
                        completionAttempts.value = 0;
                        completionStreak.value = 0;
                    }
                    
                    isLoading.value = true;
                    completionAnswerRevealed.value = false;
                    completionSelectedWords.value = [];
                    completionIsCorrect.value = false;
                    
                    try {
                        // Select random surah from selected ones
                        const randomSurahNum = selectedSurahs.value[
                            Math.floor(Math.random() * selectedSurahs.value.length)
                        ];
                        
                        // Get verses for this surah
                        const surahVerses = quranData.value[randomSurahNum];
                        if (!surahVerses || surahVerses.length === 0) {
                            throw new Error('No verses found for selected surah');
                        }
                        
                        // Select a random verse
                        const randomVerseIndex = Math.floor(Math.random() * surahVerses.length);
                        const verseNumber = randomVerseIndex + 1;
                        const verseText = surahVerses[randomVerseIndex].text;
                        
                        // Split verse into words
                        const words = verseText.split(/\s+/).filter(w => w.length > 0);
                        
                        if (words.length < 3) {
                            throw new Error('Verse too short for this quiz');
                        }
                        
                        // Determine how many words to blank (between 2-5)
                        const blankCount = Math.floor(2 + Math.random() * 4); // Random between 2-5
                        
                        // Randomly select which words to blank
                        const blankIndices = new Set();
                        while (blankIndices.size < blankCount) {
                            blankIndices.add(Math.floor(Math.random() * words.length));
                        }
                        
                        // Create display array with blanks
                        const display = words.map((word, index) => ({
                            text: word,
                            isBlank: blankIndices.has(index),
                            originalIndex: index
                        }));
                        
                        // Get correct answers in RIGHT-TO-LEFT order (highest index to lowest)
                        // This represents reading from right to left in Arabic
                        const correctAnswersArray = Array.from(blankIndices)
                            .sort((a, b) => b - a) // Sort in descending order (right to left)
                            .map(index => words[index]);
                        
                        completionVerse.value = {
                            chapter: parseInt(randomSurahNum),
                            verse: verseNumber,
                            text: verseText
                        };
                        
                        completionVerseDisplay.value = display;
                        completionCorrectAnswers.value = correctAnswersArray;
                        // Store blank indices in RIGHT-TO-LEFT order for visual filling and answer validation
                        // Highest index first (rightmost blank) = position 0
                        // Lowest index last (leftmost blank) = last position
                        completionBlankIndices.value = Array.from(blankIndices).sort((a, b) => b - a);
                        completionFilledWords.value = {}; // Reset filled words map
                        completionTotalMissing.value = blankCount;
                        completionMissingCount.value = 0;
                        
                        // Get random wrong words from other verses
                        const wrongWords = new Set();
                        const allWords = [];
                        
                        Object.keys(quranData.value).forEach(surahKey => {
                            quranData.value[surahKey].forEach(verse => {
                                verse.text.split(/\s+/).filter(w => w.length > 0).forEach(word => {
                                    allWords.push(word);
                                });
                            });
                        });
                        
                        // Add wrong words until we have enough
                        while (wrongWords.size < blankCount * 2) {
                            const randomWord = allWords[Math.floor(Math.random() * allWords.length)];
                            if (!correctAnswersArray.includes(randomWord)) {
                                wrongWords.add(randomWord);
                            }
                        }
                        
                        // Combine and shuffle options
                        const options = [
                            ...correctAnswersArray.map(word => ({ text: word, isCorrect: true })),
                            ...Array.from(wrongWords).map(word => ({ text: word, isCorrect: false }))
                        ];
                        
                        // Fisher-Yates shuffle
                        for (let i = options.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [options[i], options[j]] = [options[j], options[i]];
                        }
                        
                        completionOptions.value = options;
                    } catch (err) {
                        console.error('Error generating completion question:', err);
                        error.value = 'Failed to generate question.';
                    } finally {
                        isLoading.value = false;
                    }
                };

                // Helper function to get the word filled at a specific blank position
                const getFilledWord = (verseWordIndex) => {
                    // Guard checks
                    if (!completionBlankIndices.value || completionBlankIndices.value.length === 0) {
                        return null;
                    }
                    
                    // Find position in RIGHT-TO-LEFT sequence (highest index = position 0 = rightmost blank)
                    const positionInRTLSequence = completionBlankIndices.value.indexOf(verseWordIndex);
                    if (positionInRTLSequence === -1) return null; // Not a blank position
                    
                    // REVERSE mapping: get the word from the opposite end of the selection array
                    // This ensures first click fills rightmost blank VISUALLY
                    const reversedPosition = (completionBlankIndices.value.length - 1) - positionInRTLSequence;
                    const selectedWordIndex = completionSelectedWords.value[reversedPosition];
                    if (selectedWordIndex === undefined || selectedWordIndex === null) return null;
                    
                    const option = completionOptions.value[selectedWordIndex];
                    return option && option.text ? option.text : null;
                };

                // Select a completion word
                const selectCompletionWord = (index) => {
                    if (!completionSelectedWords.value.includes(index)) {
                        completionSelectedWords.value.push(index);
                        completionMissingCount.value++;
                    }
                };

                // Check completion answer
                const checkCompletionAnswer = async () => {
                    completionAnswerRevealed.value = true;
                    
                    // Check if selected words match correct answers in REVERSED order
                    // Since we use reversed mapping for display, we need to reverse the selected words too
                    const reversedSelectedIndices = completionSelectedWords.value.slice().reverse();
                    const selectedWordsText = reversedSelectedIndices.map(i => completionOptions.value[i].text);
                    const isCorrect = selectedWordsText.length === completionCorrectAnswers.value.length &&
                                     selectedWordsText.every((word, i) => word === completionCorrectAnswers.value[i]);
                    
                    completionIsCorrect.value = isCorrect;
                    
                    // Update session score
                    completionAttempts.value++;
                    if (isCorrect) {
                        completionScore.value++;
                        completionStreak.value++;
                    } else {
                        completionStreak.value = 0;
                    }
                    
                    // Save score
                    try {
                        await QuizDB.saveScore('verse-completion', isCorrect ? 1 : 0, {
                            surah: completionVerse.value.chapter,
                            verse: completionVerse.value.verse,
                            missingWords: completionCorrectAnswers.value.length,
                            selectedCorrectly: isCorrect,
                            streak: completionStreak.value
                        });
                    } catch (err) {
                        console.error('Error saving score:', err);
                    }

                    // Auto-generate new question after delay
                    setTimeout(() => {
                        generateCompletionQuestion();
                    }, 3000);
                };

                // Generate continuation question
                const generateContinuationQuestion = async () => {
                    if (!selectedSurahs.value.length) return;
                    
                    // Reset scores if this is a new session
                    if (!continuationVerse.value) {
                        continuationScore.value = 0;
                        continuationAttempts.value = 0;
                        continuationStreak.value = 0;
                    }
                    
                    isLoading.value = true;
                    continuationAnswerRevealed.value = false;
                    selectedWrongContinuation.value = null;
                    
                    try {
                        // Select random surah from selected ones
                        const randomSurahNum = selectedSurahs.value[
                            Math.floor(Math.random() * selectedSurahs.value.length)
                        ];
                        
                        // Get verses for this surah
                        const surahVerses = quranData.value[randomSurahNum];
                        if (!surahVerses || surahVerses.length === 0) {
                            throw new Error('No verses found for selected surah');
                        }
                        
                        // Select a verse that has BOTH next and previous (not first, not last)
                        // This ensures any question type (next or previous) is valid
                        const selectedVerseIndex = 1 + Math.floor(Math.random() * (surahVerses.length - 2));
                        
                        // NOW decide randomly if asking for next or previous
                        continuationType.value = Math.random() < 0.5 ? 'next' : 'previous';
                        
                        const verseNumber = selectedVerseIndex + 1;
                        
                        // Set current verse
                        continuationVerse.value = {
                            chapter: parseInt(randomSurahNum),
                            verse: verseNumber,
                            text: surahVerses[selectedVerseIndex].text
                        };

                        // Determine correct answer verse index based on question type
                        const correctVerseIndex = continuationType.value === 'next' 
                            ? selectedVerseIndex + 1 
                            : selectedVerseIndex - 1;

                        // Create options
                        const options = [];
                        
                        // Add correct answer
                        options.push({
                            text: surahVerses[correctVerseIndex].text,
                            verse: correctVerseIndex + 1,  // Display number (1-based)
                            isCorrect: true
                        });

                        console.log('üü¶ QUESTION GENERATED:');
                        console.log('  Type (badge):', continuationType.value);
                        console.log('  Display Verse Index:', selectedVerseIndex, '(shows verse', selectedVerseIndex + 1, ')');
                        console.log('  Correct Verse Index:', correctVerseIndex, '(verse', correctVerseIndex + 1, ')');
                        console.log('  Correct answer text:', surahVerses[correctVerseIndex].text);
                        console.log('  Correct answer object:', options[0]);

                        // Add wrong answers from different verses (avoid adjacent verses)
                        const usedIndices = new Set([selectedVerseIndex, correctVerseIndex]);
                        while (options.length < 4) {
                            const randomIndex = Math.floor(Math.random() * surahVerses.length);
                            if (!usedIndices.has(randomIndex)) {
                                usedIndices.add(randomIndex);
                                options.push({
                                    text: surahVerses[randomIndex].text,
                                    verse: randomIndex + 1,
                                    isCorrect: false
                                });
                            }
                        }

                        // Fisher-Yates shuffle
                        for (let i = options.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [options[i], options[j]] = [options[j], options[i]];
                        }

                        continuationOptions.value = options;
                    } catch (err) {
                        console.error('Error generating continuation question:', err);
                        error.value = 'Failed to generate question.';
                    } finally {
                        isLoading.value = false;
                    }
                };

                // Check continuation answer
                const checkContinuationAnswer = async (index) => {
                    continuationAnswerRevealed.value = true;
                    const isCorrect = continuationOptions.value[index].isCorrect;
                    
                    console.log('üü© ANSWER SUBMITTED:');
                    console.log('  Selected option index:', index);
                    console.log('  Selected option text:', continuationOptions.value[index].text);
                    console.log('  Selected option verse:', continuationOptions.value[index].verse);
                    console.log('  isCorrect flag:', isCorrect);
                    console.log('  Correct answer was:', continuationOptions.value.find(opt => opt.isCorrect));
                    
                    if (!isCorrect) {
                        selectedWrongContinuation.value = index;
                    }
                    
                    // Update session score
                    continuationAttempts.value++;
                    if (isCorrect) {
                        continuationScore.value++;
                        continuationStreak.value++;
                    } else {
                        continuationStreak.value = 0;
                    }
                    
                    // Save score
                    try {
                        await QuizDB.saveScore('test-continuation', isCorrect ? 1 : 0, {
                            surah: continuationVerse.value.chapter,
                            verse: continuationVerse.value.verse,
                            type: continuationType.value,
                            selectedVerse: continuationOptions.value[index].verse,
                            correctVerse: continuationOptions.value.find(opt => opt.isCorrect).verse,
                            streak: continuationStreak.value
                        });
                    } catch (err) {
                        console.error('Error saving score:', err);
                    }

                    // Auto-generate new question after delay
                    setTimeout(() => {
                        generateContinuationQuestion();
                    }, 3000);
                };

                // Lightning Round Functions
                const startLightningRound = async () => {
                    if (!lightningSelectedTime.value || !lightningSelectedDifficulty.value) return;
                    
                    // Initialize round
                    lightningTimeLeft.value = lightningSelectedTime.value;
                    lightningTotalTime.value = lightningSelectedTime.value;
                    lightningScore.value = 0;
                    lightningAttempts.value = 0;
                    lightningIsActive.value = true;
                    lightningRoundEnded.value = false;
                    lightningAnswerRevealed.value = false;
                    
                    // Set mistake limits based on difficulty
                    if (lightningSelectedDifficulty.value === 'easy') {
                        lightningMaxMistakes.value = Infinity;
                        lightningMistakesLeft.value = Infinity;
                    } else if (lightningSelectedDifficulty.value === 'medium') {
                        lightningMaxMistakes.value = 3;
                        lightningMistakesLeft.value = 3;
                    } else { // hard
                        lightningMaxMistakes.value = 1;
                        lightningMistakesLeft.value = 1;
                    }
                    
                    // Start countdown timer
                    lightningTimerId.value = setInterval(() => {
                        lightningTimeLeft.value--;
                        
                        if (lightningTimeLeft.value <= 0) {
                            endLightningRound();
                        }
                    }, 1000);
                    
                    // Generate first question
                    await generateLightningQuestion();
                };

                const generateLightningQuestion = async () => {
                    if (!lightningIsActive.value || !selectedSurahs.value.length) return;
                    
                    lightningAnswerRevealed.value = false;
                    lightningAnswerIsCorrect.value = false;
                    
                    try {
                        // Randomly pick between continuation and translation
                        lightningCurrentQuestionType.value = Math.random() < 0.5 ? 'continuation' : 'translation';
                        
                        if (lightningCurrentQuestionType.value === 'continuation') {
                            await generateLightningContinuationQuestion();
                        } else {
                            await generateLightningTranslationQuestion();
                        }
                    } catch (err) {
                        console.error('Error generating lightning question:', err);
                    }
                };

                const generateLightningContinuationQuestion = async () => {
                    try {
                        const randomSurahNum = selectedSurahs.value[
                            Math.floor(Math.random() * selectedSurahs.value.length)
                        ];
                        
                        const surahVerses = quranData.value[randomSurahNum];
                        if (!surahVerses || surahVerses.length === 0) {
                            throw new Error('No verses found');
                        }
                        
                        // Select a verse that has BOTH next and previous (not first, not last)
                        const selectedVerseIndex = 1 + Math.floor(Math.random() * (surahVerses.length - 2));
                        
                        // NOW decide randomly if asking for next or previous
                        const continuationType = Math.random() < 0.5 ? 'next' : 'previous';
                        
                        const verseNumber = selectedVerseIndex + 1;
                        lightningCurrentQuestion.value = {
                            chapter: parseInt(randomSurahNum),
                            verse: verseNumber,
                            text: surahVerses[selectedVerseIndex].text,
                            type: continuationType
                        };
                        
                        const correctVerseIndex = continuationType === 'next' 
                            ? selectedVerseIndex + 1 
                            : selectedVerseIndex - 1;
                        
                        const options = [];
                        options.push({
                            text: surahVerses[correctVerseIndex].text,
                            verse: correctVerseIndex + 1,
                            isCorrect: true
                        });
                        
                        const usedIndices = new Set([selectedVerseIndex, correctVerseIndex]);
                        while (options.length < 4) {
                            const randomIndex = Math.floor(Math.random() * surahVerses.length);
                            if (!usedIndices.has(randomIndex)) {
                                options.push({
                                    text: surahVerses[randomIndex].text,
                                    verse: randomIndex + 1,
                                    isCorrect: false
                                });
                                usedIndices.add(randomIndex);
                            }
                        }
                        
                        // Fisher-Yates shuffle
                        for (let i = options.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [options[i], options[j]] = [options[j], options[i]];
                        }
                        
                        lightningOptions.value = options;
                    } catch (err) {
                        console.error('Error generating continuation question:', err);
                    }
                };

                const generateLightningTranslationQuestion = async () => {
                    try {
                        const randomSurahNum = selectedSurahs.value[
                            Math.floor(Math.random() * selectedSurahs.value.length)
                        ];
                        
                        const surahVerses = quranData.value[randomSurahNum];
                        const randomVerseIndex = Math.floor(Math.random() * surahVerses.length);
                        const verseNumber = randomVerseIndex + 1;
                        
                        lightningCurrentQuestion.value = {
                            chapter: parseInt(randomSurahNum),
                            verse: verseNumber,
                            text: surahVerses[randomVerseIndex].text,
                            type: 'translation'
                        };
                        
                        const correctTranslation = translationData.value[randomSurahNum].find(
                            v => v.verse === verseNumber
                        );
                        
                        const wrongTranslations = getRandomVerses(lightningCurrentQuestion.value, 3);
                        
                        const options = [
                            { text: correctTranslation.text, isCorrect: true },
                            ...wrongTranslations.map(t => ({ text: t.text, isCorrect: false }))
                        ];
                        
                        // Fisher-Yates shuffle
                        for (let i = options.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [options[i], options[j]] = [options[j], options[i]];
                        }
                        
                        lightningOptions.value = options;
                    } catch (err) {
                        console.error('Error generating translation question:', err);
                    }
                };

                const checkLightningAnswer = (index) => {
                    if (!lightningIsActive.value || lightningAnswerRevealed.value) return;
                    
                    lightningAnswerRevealed.value = true;
                    const isCorrect = lightningOptions.value[index].isCorrect;
                    lightningAnswerIsCorrect.value = isCorrect;
                    
                    // Update stats
                    lightningAttempts.value++;
                    if (isCorrect) {
                        lightningScore.value++;
                    } else {
                        if (lightningMistakesLeft.value !== Infinity) {
                            lightningMistakesLeft.value--;
                        }
                        
                        // Check if round should end
                        if (lightningMistakesLeft.value < 0 || (lightningSelectedDifficulty.value === 'hard' && !isCorrect)) {
                            setTimeout(() => {
                                endLightningRound();
                            }, 500);
                            return;
                        }
                    }
                    
                    // Auto-generate next question after 500ms
                    setTimeout(() => {
                        if (lightningIsActive.value) {
                            generateLightningQuestion();
                        }
                    }, 500);
                };

                const endLightningRound = () => {
                    lightningIsActive.value = false;
                    lightningRoundEnded.value = true;
                    lightningTimeRemaining.value = lightningTimeLeft.value;
                    
                    if (lightningTimerId.value) {
                        clearInterval(lightningTimerId.value);
                    }
                };

                const resetLightningRound = () => {
                    lightningSelectedTime.value = null;
                    lightningSelectedDifficulty.value = null;
                    lightningTimeLeft.value = 0;
                    lightningTotalTime.value = 0;
                    lightningScore.value = 0;
                    lightningAttempts.value = 0;
                    lightningMistakesLeft.value = 0;
                    lightningMaxMistakes.value = 0;
                    lightningIsActive.value = false;
                    lightningCurrentQuestion.value = null;
                    lightningCurrentQuestionType.value = null;
                    lightningOptions.value = [];
                    lightningAnswerRevealed.value = false;
                    lightningAnswerIsCorrect.value = false;
                    lightningRoundEnded.value = false;
                    lightningTimeRemaining.value = 0;
                    
                    if (lightningTimerId.value) {
                        clearInterval(lightningTimerId.value);
                    }
                };

                const saveLightningScore = async () => {
                    try {
                        const accuracy = lightningAttempts.value > 0 
                            ? Math.round((lightningScore.value / lightningAttempts.value) * 100) 
                            : 0;
                        
                        await QuizDB.saveScore('lightning-round', lightningScore.value, {
                            difficulty: lightningSelectedDifficulty.value,
                            totalTime: lightningTotalTime.value,
                            timeRemaining: lightningTimeRemaining.value,
                            questionsAnswered: lightningAttempts.value,
                            accuracy: accuracy,
                            correctAnswers: lightningScore.value
                        });
                        
                        error.value = '‚úÖ Score saved successfully!';
                        setTimeout(() => {
                            error.value = null;
                        }, 3000);
                    } catch (err) {
                        console.error('Failed to save lightning score:', err);
                        error.value = 'Failed to save score.';
                    }
                };

                const tabs = ref([
                    { id: 'lightning-round', name: '‚ö° Lightning Round' },
                    { id: 'verse-completion', name: 'Verse Completion' },
                    { id: 'multiple-choice', name: 'Test Continuation' },
                    { id: 'translation-match', name: 'Translation Match' },
                    { id: 'config', name: '‚öôÔ∏è Settings' }
                ])

                // Initialize database and load settings
                const initializeApp = async () => {
                    try {
                        await QuizDB.init()
                        
                        // Load dark mode setting
                        const darkModeSetting = await QuizDB.getSetting('darkMode')
                        if (darkModeSetting) {
                            isDarkMode.value = darkModeSetting.value
                            if (isDarkMode.value) {
                                document.documentElement.classList.add('dark')
                            }
                        }

                        // Load last active tab
                        const lastTab = await QuizDB.getSetting('lastTab')
                        if (lastTab) {
                            currentTab.value = lastTab.value
                        }

                        isLoading.value = false
                    } catch (err) {
                        console.error('Failed to initialize app:', err)
                        error.value = 'Failed to load app settings. Please refresh the page.'
                        isLoading.value = false
                    }
                }

                // Toggle dark mode and save setting
                const toggleDarkMode = async () => {
                    isDarkMode.value = !isDarkMode.value
                    document.documentElement.classList.toggle('dark')
                    try {
                        await QuizDB.setSetting('darkMode', isDarkMode.value)
                    } catch (err) {
                        console.error('Failed to save dark mode setting:', err)
                    }
                }

                // Handle tab changes and save last active tab
                const changeTab = async (tabId) => {
                    // Prevent tab switching during active lightning round
                    if (lightningIsActive.value) {
                        error.value = '‚ö†Ô∏è Cannot switch tabs during an active Lightning Round. Finish or reset the round first.'
                        setTimeout(() => {
                            error.value = null
                        }, 3000)
                        return
                    }
                    
                    currentTab.value = tabId
                    try {
                        await QuizDB.setSetting('lastTab', tabId)
                    } catch (err) {
                        console.error('Failed to save last active tab:', err)
                    }
                }

                // Cleanup function for Lightning Round on unmount or before tab switch
                const cleanupLightningRound = () => {
                    if (lightningTimerId.value) {
                        clearInterval(lightningTimerId.value)
                        lightningTimerId.value = null
                    }
                    if (lightningIsActive.value) {
                        endLightningRound()
                    }
                }

                // Initialize app when component mounts
                const init = async () => {
                    await initializeApp()
                    await loadSurahs()
                    await loadQuizData() // Load quiz data after initialization
                }
                init()

                return {
                    isDarkMode,
                    currentTab,
                    tabs,
                    isLoading,
                    error,
                    surahs,
                    selectedSurahs,
                    allSurahsSelected,
                    quranData,
                    translationData,
                    currentVerse,
                    translationOptions,
                    answerRevealed,
                    selectedWrongAnswer,
                    sessionScore,
                    sessionAttempts,
                    streak,
                    continuationVerse,
                    continuationOptions,
                    continuationAnswerRevealed,
                    selectedWrongContinuation,
                    continuationScore,
                    continuationAttempts,
                    continuationStreak,
                    continuationType,
                    completionVerse,
                    completionVerseDisplay,
                    completionOptions,
                    completionSelectedWords,
                    completionAnswerRevealed,
                    completionIsCorrect,
                    completionScore,
                    completionAttempts,
                    completionStreak,
                    completionTotalMissing,
                    completionMissingCount,
                    completionBlankIndices,
                    completionFilledWords,
                    toggleDarkMode,
                    changeTab,
                    toggleSurah,
                    toggleAllSurahs,
                    saveConfig,
                    saveDefaultSettings,
                    loadDefaultSettings,
                    generateNewQuestion,
                    checkAnswer,
                    generateContinuationQuestion,
                    checkContinuationAnswer,
                    generateCompletionQuestion,
                    selectCompletionWord,
                    checkCompletionAnswer,
                    getFilledWord,
                    lightningSelectedTime,
                    lightningSelectedDifficulty,
                    lightningTimeLeft,
                    lightningTotalTime,
                    lightningScore,
                    lightningAttempts,
                    lightningMistakesLeft,
                    lightningMaxMistakes,
                    lightningIsActive,
                    lightningCurrentQuestion,
                    lightningCurrentQuestionType,
                    lightningOptions,
                    lightningAnswerRevealed,
                    lightningAnswerIsCorrect,
                    lightningRoundEnded,
                    startLightningRound,
                    generateLightningQuestion,
                    checkLightningAnswer,
                    endLightningRound,
                    resetLightningRound,
                    saveLightningScore,
                    cleanupLightningRound
                }
            }
        }).mount('#app')
    </script>
</body>
</html>
